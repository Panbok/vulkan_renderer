#ifndef VKR_SHADER_ALPHA_CUTOUT_SLANGH
#define VKR_SHADER_ALPHA_CUTOUT_SLANGH

// Per-instance alpha cutoff; values <= 0 disable alpha testing.
struct InstanceUniformBufferObject
{
    float alpha_cutoff;
};

// Applies alpha cutout for masked materials; discards when below the cutoff.
void vkr_apply_alpha_cutout(Texture2D<float4> texture, SamplerState sampler,
                            float2 uv, float cutoff)
{
    if (cutoff > 0.0f)
    {
        float alpha = texture.Sample(sampler, uv).a;
        if (alpha < cutoff)
        {
            discard;
        }
    }
}

// Applies alpha cutout using a pre-sampled alpha value (avoids double-sampling
// or reading unbound texture when the caller has already sampled diffuse).
void vkr_apply_alpha_cutout_from_alpha(float alpha, float cutoff)
{
    if (cutoff > 0.0f && alpha < cutoff)
    {
        discard;
    }
}

float vkr_alpha_cutout_hash(float3 p)
{
    p = frac(p * 0.1031f);
    p += dot(p, p.yzx + 33.33f);
    return frac((p.x + p.y) * p.z);
}

void vkr_apply_alpha_cutout_shadow(Texture2D<float4> texture, SamplerState sampler,
                                   float2 uv, float3 world_pos, float cutoff)
{
    if (abs(cutoff) < 0.0001f)
    {
        return;
    }

    float alpha = texture.Sample(sampler, uv).a;
    float c = abs(cutoff);

    if (cutoff < 0.0f)
    {
        // World-space dither to stabilize foliage cutouts in the shadow pass.
        float3 cell = floor(world_pos * 4.0f);
        float jitter = (vkr_alpha_cutout_hash(cell) - 0.5f) * 0.10f;
        if (alpha + jitter < c)
        {
            discard;
        }
    }
    else
    {
        if (alpha < c)
        {
            discard;
        }
    }
}

#endif
