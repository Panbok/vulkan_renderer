#pragma once

static const uint32_t SHADOW_CASCADE_MAX = 8u;

static const float3 SHADOW_CASCADE_DEBUG_COLORS[8] = {
    float3(1, 0, 0),
    float3(0, 1, 0),
    float3(0, 0, 1),
    float3(1, 1, 0),
    float3(1, 0, 1),
    float3(0, 1, 1),
    float3(1, 0.5, 0),
    float3(1, 1, 1),
};

static const float2 SHADOW_POISSON_16[16] = {
    float2(-0.94201624, -0.39906216),
    float2( 0.94558609, -0.76890725),
    float2(-0.09418410, -0.92938870),
    float2( 0.34495938,  0.29387760),
    float2(-0.91588581,  0.45771432),
    float2(-0.81544232, -0.87912464),
    float2(-0.38277543,  0.27676845),
    float2( 0.97484398,  0.75648379),
    float2( 0.44323325, -0.97511554),
    float2( 0.53742981, -0.47373420),
    float2(-0.26496911, -0.41893023),
    float2( 0.79197514,  0.19090188),
    float2(-0.24188840,  0.99706507),
    float2(-0.81409955,  0.91437590),
    float2( 0.19984126,  0.78641367),
    float2( 0.14383161, -0.14100790),
};

float shadow_vec4_array_get(float4 arr[2], uint idx)
{
    uint i = min(idx, SHADOW_CASCADE_MAX - 1u);
    uint vec = i >> 2;
    uint lane = i & 3u;
    float4 v = arr[vec];
    return (lane == 0u) ? v.x :
           (lane == 1u) ? v.y :
           (lane == 2u) ? v.z :
                          v.w;
}

float shadow_split_far_for(uint cascade)
{
    return shadow_vec4_array_get(g_ubo.shadow_split_far, cascade);
}

uint select_cascade(float view_depth)
{
    uint count = max(g_ubo.shadow_cascade_count, 1u);
    count = min(count, SHADOW_CASCADE_MAX);

    if (count <= 1u) return 0u;

    const float CASCADE_EPSILON = 1e-4f;

    for (uint i = 0u; i < count - 1u; ++i)
    {
        if (view_depth < shadow_split_far_for(i) - CASCADE_EPSILON)
        {
            return i;
        }
    }

    return count - 1u;
}

// Maximum UV deviation from [0,1] range before considering the cascade as not
// covering. A larger value makes cascade selection more lenient, reducing
// bright "seam" lines at cascade boundaries at the cost of sampling shadow map
// edges more often (minor quality reduction at boundaries).
float shadow_map_inv_size_for(uint cascade)
{
    return shadow_vec4_array_get(g_ubo.shadow_map_inv_size, cascade);
}

float shadow_uv_margin(uint cascade)
{
    // Keep this tight. If we allow fragments outside [0,1] to be considered
    // "covered", we end up clamping to the shadow-map edge which often yields
    // fully-lit seams that track the camera/cascade split.
    float texel_margin = shadow_map_inv_size_for(cascade) * 1.0f; // 1 texel
    return max(texel_margin, 0.00025f);
}

struct ShadowProjection
{
    float2 uv;
    float z;
    float2 uv_clamped;
    float z_clamped;
    bool uv_out;
    bool z_out;
    float uv_out_amount; // max distance outside [0,1] (0 = inside)
};

float shadow_uv_soft_margin(uint cascade)
{
    // Soft fallback: allow a few texels out-of-range to avoid 1-pixel “holes”
    // near cascade boundaries / snapping.
    return max(shadow_map_inv_size_for(cascade) * 8.0f, 0.001f);
}

float shadow_world_units_per_texel(uint cascade)
{
    return shadow_vec4_array_get(g_ubo.shadow_world_units_per_texel, cascade);
}

float2 shadow_light_space_origin(uint cascade)
{
    float x = shadow_vec4_array_get(g_ubo.shadow_light_space_origin_x, cascade);
    float y = shadow_vec4_array_get(g_ubo.shadow_light_space_origin_y, cascade);
    return float2(x, y);
}

float shadow_pcf_radius_texels(uint cascade);

float shadow_uv_kernel_margin(uint cascade)
{
    // If the receiver UV is close enough to the shadow map edge that the PCF
    // kernel samples outside [0,1], border sampling can create bright seams.
    // Treat that region as uncovered so we can fall back to a better cascade.
    float r = shadow_pcf_radius_texels(cascade);
    if (r <= 0.0f)
    {
        return 0.0f;
    }
    return shadow_map_inv_size_for(cascade) * (r + 0.5f);
}

ShadowProjection project_shadow(float3 world_pos, uint cascade)
{
    ShadowProjection p;
    float4 clip = mul(g_ubo.shadow_view_projection[cascade], float4(world_pos, 1.0f));
    clip.xyz /= clip.w;

    p.uv = clip.xy * 0.5f + 0.5f;
    p.z = clip.z;

    float margin = shadow_uv_margin(cascade);
    float kernel_margin = shadow_uv_kernel_margin(cascade);
    // Treat the PCF kernel as part of the coverage test: if the kernel would
    // sample outside [0,1], edge/border sampling can create bright seams.
    float2 uv = p.uv;
    float edge = min(min(uv.x, 1.0f - uv.x), min(uv.y, 1.0f - uv.y));
    bool kernel_hits_edge = (edge < kernel_margin);

    p.uv_out = (p.uv.x < -margin || p.uv.x > 1.0f + margin ||
                p.uv.y < -margin || p.uv.y > 1.0f + margin ||
                kernel_hits_edge);

    // Z check: allow small deviation for depth precision issues
    float z_margin = 0.002f;
    p.z_out = (p.z < -z_margin || p.z > 1.0f + z_margin);

    p.uv_clamped = clamp(p.uv, 0.0f, 1.0f);
    p.z_clamped = saturate(p.z);

    float2 out_lo = max(0.0f.xx, 0.0f.xx - p.uv);
    float2 out_hi = max(0.0f.xx, p.uv - 1.0f.xx);
    p.uv_out_amount = max(max(out_lo.x, out_lo.y), max(out_hi.x, out_hi.y));

    return p;
}

float shadow_hash12(float2 p)
{
    float3 p3 = frac(float3(p.xyx) * 0.1031f);
    p3 += dot(p3, p3.yzx + 33.33f);
    return frac((p3.x + p3.y) * p3.z);
}

float2 shadow_rotate(float2 v, float2 cs)
{
    return float2(v.x * cs.x - v.y * cs.y, v.x * cs.y + v.y * cs.x);
}

float2 shadow_light_space_xy(float3 world_pos)
{
    float3 light_dir = normalize(g_ubo.dir_direction);
    float3 up_ref = (abs(light_dir.y) > 0.99f) ? float3(0.0f, 0.0f, 1.0f)
                                               : float3(0.0f, 1.0f, 0.0f);
    float3 right = normalize(cross(up_ref, light_dir));
    float3 up = cross(light_dir, right);
    return float2(dot(world_pos, right), dot(world_pos, up));
}

float shadow_pcf_radius_texels(uint cascade)
{
    float r0 = max(g_ubo.shadow_pcf_radius, 0.0f);
    if (r0 <= 0.0f) return 0.0f;

    // Keep the filter roughly constant in world-space across cascades by
    // scaling the radius in texels according to world-units-per-texel.
    float base = max(shadow_world_units_per_texel(0u), 1e-6f);
    float cur = shadow_world_units_per_texel(cascade);
    float scale = clamp(cur / base, 0.5f, 2.0f);
    return clamp(r0 * scale, 0.0f, 4.0f);
}

float sample_shadow_pcf(Texture2DArray<float> map,
                        SamplerComparisonState samp,
                        float2 uv,
                        float compare_depth,
                        float bias,
                        float3 world_pos,
                        uint cascade)
{
    float inv = shadow_map_inv_size_for(cascade);
    float2 inv_size = float2(inv, inv);

    // Avoid clamping to 1.0: ref=1 with LESS/LEQUAL tends to produce fully-lit
    // seams for fragments that drift slightly past the cascade far plane.
    float cmp = clamp(compare_depth - bias, 0.0f, 1.0f - 1e-5f);

    float r_tex = shadow_pcf_radius_texels(cascade);
    if (r_tex <= 0.0f)
    {
        return map.SampleCmpLevelZero(samp, float3(uv, (float)cascade), cmp);
    }

    float2 radius_uv = inv_size * r_tex;
    float sum = 0.0f;

    float wupt = max(shadow_world_units_per_texel(cascade), 1e-6f);
    float2 light_xy = shadow_light_space_xy(world_pos);
    float2 origin = shadow_light_space_origin(cascade);
    float2 cell = floor((light_xy - origin) / wupt);
    float2 seed = cell + (float)cascade * float2(37.0f, 17.0f);
    float angle = shadow_hash12(seed) * 6.2831853f;
    float2 cs = float2(cos(angle), sin(angle));

    [unroll]
    for (uint i = 0u; i < 16u; ++i)
    {
        float2 tap = shadow_rotate(SHADOW_POISSON_16[i], cs);
        float2 uv_tap = clamp(uv + tap * radius_uv, 0.0f, 1.0f);
        sum += map.SampleCmpLevelZero(samp, float3(uv_tap, (float)cascade),
                                      cmp);
    }

    return sum * (1.0f / 16.0f);
}

// Try to find a cascade that covers the fragment. Returns the cascade index
// and whether coverage was found. Prioritizes the initially selected cascade,
// then searches neighbors to handle coverage gaps from stabilization snapping.
struct CascadeLookup
{
    uint cascade;
    bool covered;
    ShadowProjection proj;
};

uint clamp_cascade_index(uint idx)
{
    uint count = min(max(g_ubo.shadow_cascade_count, 1u), SHADOW_CASCADE_MAX);
    if (count == 0u) return 0u;
    return min(idx, count - 1u);
}

CascadeLookup find_covering_cascade(float3 world_pos, uint initial_cascade)
{
    CascadeLookup result;
    initial_cascade = clamp_cascade_index(initial_cascade);
    result.cascade = initial_cascade;
    result.covered = false;
    result.proj = project_shadow(world_pos, initial_cascade);

    uint count = min(max(g_ubo.shadow_cascade_count, 1u), SHADOW_CASCADE_MAX);

    // If the initially selected cascade covers, keep it. This avoids temporal
    // instability from switching cascades based on marginal coverage heuristics.
    if (!result.proj.uv_out && !result.proj.z_out)
    {
        result.covered = true;
        return result;
    }

    // Otherwise, search nearest cascades first. This produces stable results
    // when two cascades overlap (guard band, snapping, or frustum fit changes).
    //
    // Order example for initial=1: 1,0,2,3
    // Order example for initial=2: 2,1,3,0
    [unroll]
    for (uint step = 1u; step < SHADOW_CASCADE_MAX; ++step)
    {
        uint left = (initial_cascade >= step) ? (initial_cascade - step) : 0u;
        if (left < count)
        {
            ShadowProjection p = project_shadow(world_pos, left);
            if (!p.uv_out && !p.z_out)
            {
                result.cascade = left;
                result.covered = true;
                result.proj = p;
                return result;
            }
        }

        uint right = initial_cascade + step;
        if (right < count)
        {
            ShadowProjection p = project_shadow(world_pos, right);
            if (!p.uv_out && !p.z_out)
            {
                result.cascade = right;
                result.covered = true;
                result.proj = p;
                return result;
            }
        }
    }

    // Soft fallback: if we failed strict coverage due to tiny numerical drift,
    // pick the cascade that is only slightly out-of-range in UV and sample it
    // clamped. This prevents straight “lit seams” that track the camera.
    float z_soft = 0.02f;
    uint best = initial_cascade;
    float best_out = 1e9f;
    ShadowProjection best_proj = result.proj;

    [unroll]
    for (uint i = 0u; i < SHADOW_CASCADE_MAX; ++i)
    {
        if (i >= count) continue;
        ShadowProjection p = (i == initial_cascade) ? result.proj : project_shadow(world_pos, i);
        bool z_ok = (p.z >= -z_soft && p.z <= 1.0f + z_soft);
        if (!z_ok) continue;
        float soft_uv = shadow_uv_soft_margin(i);
        float2 uv = p.uv_clamped;
        float edge = min(min(uv.x, 1.0f - uv.x), min(uv.y, 1.0f - uv.y));
        float kernel_margin = shadow_uv_kernel_margin(i);
        bool kernel_ok = (edge >= kernel_margin);
        if (p.uv_out_amount <= soft_uv && kernel_ok)
        {
            float out_amt = p.uv_out_amount + (float)i * 1e-6f; // stable tie-break
            if (out_amt < best_out)
            {
                best_out = out_amt;
                best = i;
                best_proj = p;
            }
        }
    }

    if (best_out < 1e8f)
    {
        result.cascade = best;
        result.covered = true;
        result.proj = best_proj;
        return result;
    }

    return result;
}

struct ShadowResult
{
    float factor;
    uint effective_cascade;
    bool covered;
};

ShadowResult calculate_shadow_ex(float3 world_pos, float3 normal, uint initial_cascade)
{
    ShadowResult result;
    result.factor = 1.0f;
    result.effective_cascade = initial_cascade;
    result.covered = false;

    if (g_ubo.shadow_enabled == 0u || g_ubo.dir_enabled == 0u)
    {
        return result;
    }

    // Find a cascade that actually covers this fragment
    CascadeLookup lookup = find_covering_cascade(world_pos, initial_cascade);
    if (!lookup.covered)
    {
        // No cascade covers this fragment - treat as lit
        return result;
    }

    result.effective_cascade = lookup.cascade;
    result.covered = true;
    float2 uv = lookup.proj.uv_clamped;
    float z = lookup.proj.z_clamped;

    float3 light_dir = normalize(-g_ubo.dir_direction);
    float ndotl = saturate(dot(normal, light_dir));
    float wupt = shadow_world_units_per_texel(result.effective_cascade);
    float base_bias = g_ubo.shadow_bias + g_ubo.shadow_normal_bias * (1.0f - ndotl);
    base_bias += g_ubo.shadow_bias_texel_scale * wupt;

    float slope = sqrt(max(1.0f - ndotl * ndotl, 0.0f)) / max(ndotl, 1e-3f);
    slope = min(slope, 8.0f);
    float slope_bias = g_ubo.shadow_slope_bias +
                       g_ubo.shadow_slope_bias_texel_scale * wupt;

    float bias = max(base_bias + slope_bias * slope, 0.0f);

    result.factor = sample_shadow_pcf(shadow_map, shadow_sampler, uv, z, bias,
                                      world_pos, result.effective_cascade);

    return result;
}

float calculate_shadow(float3 world_pos, float3 normal, uint cascade)
{
    return calculate_shadow_ex(world_pos, normal, cascade).factor;
}

ShadowResult calculate_shadow_blended(float3 world_pos, float3 normal, float view_depth, uint initial_cascade)
{
    uint selected = clamp_cascade_index(initial_cascade);
    ShadowResult base = calculate_shadow_ex(world_pos, normal, selected);
    if (!base.covered)
    {
        return base;
    }

    uint count = min(max(g_ubo.shadow_cascade_count, 1u), SHADOW_CASCADE_MAX);
    if (count <= 1u)
    {
        return base;
    }

    // Blend near the selected cascade's far split to smooth transitions.
    // Range is expressed in view-space units (positive forward).
    float blend_range = max(g_ubo.shadow_cascade_blend_range, 0.0f);
    if (blend_range <= 0.0f)
    {
        return base;
    }

    uint next = min(selected + 1u, count - 1u);
    if (next == selected)
    {
        return base;
    }

    float split_far = shadow_split_far_for(selected);

    float start = split_far - blend_range;
    float t = saturate((view_depth - start) / max(blend_range, 1e-4f));
    if (t <= 0.0f)
    {
        return base;
    }

    ShadowResult alt = calculate_shadow_ex(world_pos, normal, next);
    if (!alt.covered)
    {
        return base;
    }

    ShadowResult out_r = base;
    out_r.factor = lerp(base.factor, alt.factor, t);
    // Keep effective_cascade as the base cascade so debug modes remain readable.
    return out_r;
}

float sample_shadow_depth(uint cascade, float2 uv)
{
    // SampleCmp samplers do not reliably return raw depth via Sample().
    // Use Load() for debug visualization (nearest, no sampler).
    uint dim_x = 1u;
    uint dim_y = 1u;
    uint dim_layers = 1u;
    shadow_map.GetDimensions(dim_x, dim_y, dim_layers);

    int2 p = int2(clamp(uv, 0.0f, 1.0f) * float2((float)max(dim_x - 1u, 1u),
                                                 (float)max(dim_y - 1u, 1u)));
    uint layer = min(cascade, max(dim_layers, 1u) - 1u);
    return shadow_map.Load(int4(p, layer, 0)).r;
}
